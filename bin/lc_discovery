#!/usr/bin/env ruby
require "awesome_print"
require "yaml"
require 'gli'
require_relative "../lib/lc_discovery/discovery"
 
include GLI::App

ENV["GLI_DEBUG"] = "true"


#----------
# show numbered list of known project homes
# user can pick number or wildcard string match
def numbered_homes
  s = "\n    active?  path\n    -------  ----\n"
  @config[:homes].each_with_index do |home, i|
    s << sprintf("%-4d %-7s %s\n", i, home[:active], home[:path])
  end
  return s
end




def no_projects?
  @config[:homes].map{ |x| x[:projects] }.flatten.empty?
end






#----------

program_desc 'Do lots of things with geographix'
 
flag [:c, :cfg_path], :default_value => "./config.yml"

pre do |global_options, command, options,args|
  if File.exists?(global_options[:cfg_path])
    @config = YAML.load_file(global_options[:cfg_path])
  else
    exit_now! "No config file found at #{global_options[:cfg_path]}"
    #raise ArgumentError.new("invalid options file path: #{opts_path}") 
  end
  true
end

post do |global_options, command, options, args|
  File.open(global_options[:cfg_path], 'w') do |f| 
    f.write @config.to_yaml
  end
end





#----------
desc "Toggle the active state for selected homes."
long_desc "long description"
command :home_toggle do |c|
  c.action do |global_options,options,args|
    if @config[:homes].empty?
      puts "There are no homes yet! Use \"add_home\" first."
    else
      puts "\nEnter home number(s) to toggle active status...\n\n"

      puts "\n    active?  path\n    -------  ----\n"
      @config[:homes].each_with_index do |home, i|
        printf("%-4d %-7s %s\n", i, home[:active], home[:path])
      end

      print "\n(use commas for multiple selections):"

      choice = gets.chomp.split(",").select{ |x| /\d+/.match x }.uniq
      
      @config[:homes].each_with_index do |home, i|
        if choice.include? i.to_s
          toggle = ! @config[:homes][i][:active]
          puts "active=#{toggle} for home: #{@config[:homes][i][:path]}"
          @config[:homes][i][:active] = toggle
          choice.delete_at(i)
        end
      end
      puts "\n(skipped invalid entries)" unless choice.empty?

    end
  end
end



#----------
desc "Deactivate selected homes and/or projects."
long_desc "long description for toggle deactive"
command :deactivate do |c|
  c.action do |global_options,options,args|
    if no_homes?
      puts "Oh noes! You need to add some homes and scan for projects first!"
    else
      puts numbered_homes
      choice = gets.chomp

      puts "DEACTIVATE choice #{choice}"
    end
  end
end




#----------
desc "Scan all selected projects and extract data types"
long_desc "long scsan"
command :scan_projects do |c|
  c.action do |global_options,options,args|
    if no_homes?
      puts "Oh noes! You need to add some homes and scan for projects first!"
    else
      puts numbered_homes
      choice = gets.chomp

    end
  end
end






#----------
desc "Choose which data types to extract from projects."
long_desc "long description for extracts"
command :extracts do |c|
  c.action do |global_options,options,args|
  end
end


########## DONE BELOW

#----------
desc "Add a new project home."
long_desc "long description for add_home"
command :add_home do |c|
  c.switch [:d, :deep]
  c.flag [:l, :label], :default_value => "unlabeled"
  c.action do |global_options,options,args|

    path = args[0].gsub("\\", "/")
    selected = @config[:homes].select{ |h| h[:path].casecmp(path)==0 }.first

    default_opts = {
      path: path, 
      active: true,
      label: options[:label],
      scan_date: Time.now,
      scan_deep: options[:deep],
      projects: []
    }

    if selected
      puts "Home is already in the list (but I'll activate it):\n #{path}"
      selected[:active] = true
    else
      if /^\/\/\w.*|^[a-z]:\/{1}\w.*/i =~ path
        @config[:homes] << default_opts
        puts "Home added: #{path}"
      else
        puts "Invalid path? #{path}"
      end
    end

  end
end


 

#---------- 
desc "Recurse through active homes and (re)build project list."
long_desc "long description of find_projects"
command :find_projects do |c|
  c.action do

    @config[:homes].each do |home|
      if home[:active]
        home[:projects].clear
        puts "Scanning for projects: #{home[:path]}"
        Discovery.project_list(home[:path], home[:deep]).each do |path|

          puts "...adding: #{path}"
          home[:projects] << {
            path: path,
            label: home[:label],
            active: true,
            extracts: []
          }
        end
        home[:scan_date] = Time.now
      end
      
    end

  end
end



 
exit run(ARGV)

=begin
begin

rescue => e
  raise e if $DEBUG
  STDERR.puts e.message
  STDERR.puts e.backtrace.join("\n")
  exit 1
end
=end
